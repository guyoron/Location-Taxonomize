<?php

/**
* @file
* A module which creates and maintains a Location Taxonomy
* which is synchronized with Data from the Location module
*/

require_once('location_taxonomize.inc');
require_once('location_taxonomize.admin.inc');

/**
 * Implements hook_locationapi().
 */
function location_taxonomize_locationapi(&$obj, $op, $a3, $a4, $a5) {
  $settings = variable_get('location_taxonomize_settings');
  $vid = variable_get('location_taxonomize_vid');
  if (!$settings['enable'] || !$vid) return;
  switch ($op) {
    // if we're saving a location, synchronize with vocab
    case 'save':
      drupal_set_message('saving');
      $saved = location_taxonomize_process_loc($obj);
      drupal_set_message(t('Location Taxonomize: %num new terms saved',array('%num' => $saved)));
  }
}

/**
 * Adds a longname field to a term
 *
 */
function _location_taxonomy_add_longname(&$term, $hlevel, $location) {
  $settings = variable_get('location_taxonomize_settings');
  $opts = $settings['longname'];
  $fields = $opts['fields'];
  $longname = array();
  switch ($hlevel) {
    case 0:
      if ($fields['country_name']) $longname[] = $location['country_name'];
    break;
    case 1:
      if ($fields['province_name']) {
        $longname[] = $location['province_name'];
      }
      if ($fields['country_name']) {
        if ($opts['country_code']) {
          if ($opts['usa'] && $location['country'] == 'us') $country = 'usa';
          else $country = 'us';
          if ($opts['cap_co']) $longname[] = strtoupper($country);
          else $longname[] = $country;
        } else {
          $longname[] = $location['country_name'];
        }
      }
    break;
    case 2:
      if ($fields['city']) {
        $longname[] = $location['city'];
      }
      if ($fields['province_name']) {
        if ($opts['province_code']) {
          if ($opts['cap_pr']) $longname[] = strtoupper($location['province']);
          else $longname[] = $location['province'];
        } else  $longname[] = $location['province_name'];
      }
      if ($fields['country_name']) {
        if ($opts['country_code']) {
          if ($opts['usa'] && $location['country'] == 'us') $country = 'usa';
          else $country = 'us';
          if ($opts['cap_co']) $longname[] = strtoupper($country);
          else $longname[] = $country;
        } else {
          $longname[] = $location['country_name'];
        }
      }
    break;
  }
  $count = count($longname);
  $longname_str = '';
  for ($i = 0; $i<$count; $i++) {
    $longname_str .= $longname[$i];
    if ($i != $count-1) $longname_str .= $opts['separator'] . ' ';
  }
  $term->location_taxonomize_longname['und'][0]['value'] = $longname_str;
}

/**
 * Given a name, hierarchy level, and parent id, this function returns the term if such a term
 * exists, and FALSE if it doesn't.
 * It returns TRUE if the term was not found but should not be saved
 * NOTE: $parentid is only necessary if $hlevel > 0. Otherwise, set $parentid = -1
 */
function _find_term($name, $hlevel, $parentid) {
  $terms = taxonomy_get_term_by_name($name);
  if (!$terms) return FALSE;      // there are no terms that match
  $withparent = array();      
  // look through matching terms and find the one(s) with the right parent
  foreach ($terms as $term) {
    //dpm($term);
    $parents = taxonomy_get_parents($term->tid);
    if (!$parents && $parentid == -1) $withparent[] = $term;    // for root-level terms  
    else if (array_pop($parents)->tid == $parentid) $withparent[] = $term;  // for all other terms (one parent is assumed)
    //dpm($withparent);
  }
  if (count($withparent) == 1) {      // there is one term that matches exactly
    //drupal_set_message($name . ' is already in, with the right parent. Not saving.');
    return array_pop($withparent);
  } else if (count($withparent) == 0){  // there are no terms that match exactly
    //drupal_set_message('it\'s in, but with different parent. Saving new term: ' . $name);
    return FALSE;
  }
  // if we get here, there was more than one term that matched exactly
  drupal_set_message('too many terms! couldn\'t save!');
  return TRUE;
}

/**
* A temporary fix for an apparent bug, due to which the country_name field is not updated during the call to
* hook_locationapi
*/
function _fix_loc_tmp($loc) {
  $loc['country_name'] = location_country_name($loc['country']);
  $loc['province_name'] = location_province_name($loc['country'],$loc['province']);
  return $loc;
}

/**
* Implements hook_menu()
*/
function location_taxonomize_menu() {
  $items = array(); 
  // module configuration page
  $items['admin/config/content/location_taxonomize'] = array(
    'title' => 'Location Taxonomize',
    'description' => 'Configuration for Location taxonomize module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('location_taxonomize_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * 
 */
function location_taxonomize_form_validate($form, $form_state) {
  $values = $form_state['values'];
  //  if we're initializing, make sure that there are no interfering vocabs
  $state = $values['location_taxonomize_vocab']['state']; 
  if ($state == 'initialization') {
    $values_init = $values['location_taxonomize_vocab'];
    $vid = variable_get('location_taxonomize_vid');
    if ($vid) form_set_error('','There seems to already be a Vocabulary
                            associated with Location Taxonomize.');
    $vocab = taxonomy_vocabulary_machine_name_load(LOCATION_TAXONOMIZE_VOCAB_NAME);
    if ($values_init['method'] == 'new' && $vocab) {
      form_set_error('','Could not create new Location Taxonomy vocabulary. A vocabulary with the name
                    \'' . LOCATION_TAXONOMIZE_VOCAB_NAME . '\' already exists.');
    }
    if ($values_init['method'] == 'existing') {
      if (!$vocab) form_set_error('', 'Could not use the existing vocabulary. There is no existing vocabulary with the name 
                                  \'' . LOCATION_TAXONOMIZE_VOCAB_NAME . '\'');
      else if ($vocab->vid != $values_init['possible_vid']) {
        form_set_error('', 'Could not use the existing vocabulary (vid ' . $values_init['possible_vid'] . '). Wrong vid.');
      }
    }
  }
  
}

/**
 * Called from the configuration form. Handles initialization of Location Taxonomy
 */
function location_taxonomize_initialize($form, $form_state) {
  $values_init = $form_state['values']['location_taxonomize_vocab'];
  $method = $values_init['method'];
  switch ($method) {
    case 'new':
      // create a new location vocabulary
      taxonomy_vocabulary_save((object) array(
        'name' => 'Location',
        'machine_name' => LOCATION_TAXONOMIZE_VOCAB_NAME,
        'description' => 'This vocabulary is synchronized with Location data automatically by the ' . LOCATION_TAXONOMIZE_MODULE_NAME . ' module',
      ));
      // save the vid of the newly created vocabulary
      $vocab = taxonomy_vocabulary_machine_name_load(LOCATION_TAXONOMIZE_VOCAB_NAME);
      $vid = $vocab->vid;
      variable_set('location_taxonomize_vid', $vid);
      $msg = 'Successfully created the Location taxonomy (vid ' . $vid . ')';
    break;
    case 'existing':
      // save the vid of the existing vocabulary
      $vid = $values_init['possible_vid'];
      variable_set('location_taxonomize_vid', $vid);
      $msg = 'Successfully connected to the existing Location Vocabulary (vid ' . $vid . ')';
    break;
  }
  drupal_set_message($msg);
  // Create the 'taxonomy_longname' field if it doesn't already exist.
  if (!field_info_field('location_taxonomize_longname')) {
    $field = array(
      'field_name' => 'location_taxonomize_longname', 
      'type' => 'text', 
    );
    field_create_field($field);
  }
  if (!field_info_instance('taxonomy_term','location_taxonomize_longname','location_taxonomize')) {
    // Create the instance on the bundle.
    $instance = array(
      'field_name' => 'location_taxonomize_longname',
      'label' => 'Long Name', 
      'entity_type' => 'taxonomy_term', 
      'bundle' => 'location_taxonomize',
    );
    field_create_instance($instance);
  }
  // set the longname fields variable
  $fields = _get_location_fields(FALSE);
  $vocab = variable_get('location_taxonomize_vocab');
  $vocab_fields = $vocab['fields'];
  $settings = variable_get('location_taxonomize_settings');
  $settings['longname']['fields'] = array();
  foreach ($fields as $field) {
    if ($vocab_fields[$field]) {
      $settings['longname']['fields'][$field] = $field;
    }
  }
  variable_set('location_taxonomize_settings', $settings);
  drupal_set_message(t('Location Taxonomize initialized successfully'));
}


/**
 * Determines if a location needs to be taxonomized. If so, it saves the appropriate terms
 * Returns the number of terms added
 */
function location_taxonomize_process_loc($obj) {
  drupal_set_message('process');
  // get settings
  $settings = variable_get('location_taxonomize_settings');
  $vid = variable_get('location_taxonomize_vid');
  $hierarchy = _location_taxonomize_get_hierarchy();
  dpm($hierarchy);
  $saved = 0;   // holds the number of newly saved terms
  // make sure the province_name and country_name fields are there and updated
  $location = _fix_loc_tmp($obj);
  dpm($location);
  $tids = array();
  // this loops through hierarchy levels and saves terms if necessary
  for ($hlevel = 0; $hlevel < count($hierarchy); $hlevel++) {
    $hlevel_name = $hierarchy[$hlevel];
    // set the term name
    $name = _location_taxonomize_create_term_name($hlevel_name, &$location, &$settings);
    // find if the term exists already or not
    if ($hlevel == 0) $parentid = -1;
    else $parentid = $tids[$hlevel-1];
    $findterm = _find_term($name, $hlevel, $parentid);
    // save if necessary
    if (!$findterm) {
      $term = (object) array(
        'name' => $name,
        'vid' => $vid,
      );
      if ($settings['longname_enable']) {
        _location_taxonomy_add_longname(&$term, $hlevel, $location);
      }
      if ($hlevel == 0) {
        $term->parent = array(0);
      } else {
        $term->parent = array($parentid);
      }
      taxonomy_term_save($term);
      $tids[] = $term->tid;
      $saved++;
    }
    else if ($findterm->tid) $tids[] = $findterm->tid;
  }
  return $saved;
}

function _location_taxonomize_create_term_name($hlevel_name, &$location, &$settings) {
  switch ($hlevel_name) {
    case 'country':
      if ($settings['naming']['country'] == 'name') $name = $location['country_name'];
      elseif ($location['country'] == 'us' && $settings['naming']['usa']) $name = 'USA';
      else $name = strtoupper($location['country']);
      break;
    case 'province':
      if ($settings['naming']['province'] == 'name') $name = $location['province_name'];
      else $name = $location['province'];
      break;
    default:
      $name = $location[$hlevel_name];
      break;
  }
  return $name;
}

////////////////////////////////////////
// Feature: Bulk taxonomize
////////////////////////////////////////

function location_taxonomize_bulk_taxonomize($form, $form_state) {
  $batch = array(
    'operations' => array(
      array('location_taxonomize_bulk_taxonomize_op', array($form_state)),
      //array('batch_example_process', array($options3, $options4)),
    ),
    'finished' => 'location_taxonomize_bulk_taxonomize_finished',
    'title' => t('Taxonomizing Locations'),
    'init_message' => t('Initializing...'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('Bulk Taxonomize encountered an error.'),
    //'file' => drupal_get_path('module', 'batch_example') . '/batch_example.inc',
  );
  batch_set($batch);
}

function location_taxonomize_bulk_taxonomize_op($form_state, &$context) {
  // initialize progress, max, and current if this is the first iteration
  if (!isset($context['sandbox']['progress'])) {
      $context['sandbox']['progress'] = 0;
      $context['sandbox']['max'] = db_query('SELECT COUNT(DISTINCT lid) FROM {location}')->fetchField();
      $context['sandbox']['current'] = 0;
      $context['results']['added'] = 0;
      $context['results']['processed'] = 0;
  }
  // maximum 20 locations per function iteration
  $limit = 10;
  // iterate through the next group of locations
  $result = db_query_range("SELECT lid, name, street, additional, city, province, postal_code, country, latitude, longitude, source FROM {location} WHERE lid != 0 ORDER BY lid ASC", $context['sandbox']['current'], $limit, array());
  $result_array = $result->fetchAllAssoc('lid');
  foreach ($result_array as $row) {
    $added = location_taxonomize_process_loc((array)$row);
    $context['results']['added'] += $added;
    $context['sandbox']['progress']++;
    $context['message'] = t('Processing location lid %n', array('%n' => $row->lid));
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
  $context['sandbox']['current'] = $context['sandbox']['progress'];
  $context['results']['processed'] = $context['sandbox']['progress'];
}

function location_taxonomize_bulk_taxonomize_finished($success, $results, $operations) {
  drupal_set_message(t('Bulk Taxonomize completed successfully!'));
  drupal_set_message(t('Processed %num locations', array('%num' => $results['processed'])));
  drupal_set_message(t('Saved %num new terms to the Location Vocabulary', array('%num' => $results['added'])));
}


